// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Crud {

void protobuf_ShutdownFile_mysqlx_5fcrud_2eproto() {
  delete Column::default_instance_;
  delete Projection::default_instance_;
  delete Collection::default_instance_;
  delete Limit::default_instance_;
  delete Order::default_instance_;
  delete UpdateOperation::default_instance_;
  delete Find::default_instance_;
  delete Insert::default_instance_;
  delete Insert_TypedRow::default_instance_;
  delete Update::default_instance_;
  delete Delete::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_mysqlx_5fcrud_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_mysqlx_5fcrud_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::Mysqlx::Expr::protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  ::Mysqlx::Datatypes::protobuf_AddDesc_mysqlx_5fdatatypes_2eproto();
  Column::default_instance_ = new Column();
  Projection::default_instance_ = new Projection();
  Collection::default_instance_ = new Collection();
  Limit::default_instance_ = new Limit();
  Order::default_instance_ = new Order();
  UpdateOperation::default_instance_ = new UpdateOperation();
  Find::default_instance_ = new Find();
  Insert::default_instance_ = new Insert();
  Insert_TypedRow::default_instance_ = new Insert_TypedRow();
  Update::default_instance_ = new Update();
  Delete::default_instance_ = new Delete();
  Column::default_instance_->InitAsDefaultInstance();
  Projection::default_instance_->InitAsDefaultInstance();
  Collection::default_instance_->InitAsDefaultInstance();
  Limit::default_instance_->InitAsDefaultInstance();
  Order::default_instance_->InitAsDefaultInstance();
  UpdateOperation::default_instance_->InitAsDefaultInstance();
  Find::default_instance_->InitAsDefaultInstance();
  Insert::default_instance_->InitAsDefaultInstance();
  Insert_TypedRow::default_instance_->InitAsDefaultInstance();
  Update::default_instance_->InitAsDefaultInstance();
  Delete::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mysqlx_5fcrud_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_mysqlx_5fcrud_2eproto_once_);
void protobuf_AddDesc_mysqlx_5fcrud_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_mysqlx_5fcrud_2eproto_once_,
                 &protobuf_AddDesc_mysqlx_5fcrud_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mysqlx_5fcrud_2eproto {
  StaticDescriptorInitializer_mysqlx_5fcrud_2eproto() {
    protobuf_AddDesc_mysqlx_5fcrud_2eproto();
  }
} static_descriptor_initializer_mysqlx_5fcrud_2eproto_;
#endif
bool DataModel_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Column::kNameFieldNumber;
const int Column::kAliasFieldNumber;
const int Column::kDocumentPathFieldNumber;
#endif  // !_MSC_VER

Column::Column()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}

void Column::InitAsDefaultInstance() {
}

Column::Column(const Column& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Column::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Column& Column::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Column* Column::default_instance_ = NULL;

Column* Column::New() const {
  return new Column;
}

void Column::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        alias_->clear();
      }
    }
  }
  document_path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Column)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_document_path;
        break;
      }

      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3: {
        if (tag == 26) {
         parse_document_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_document_path;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (int i = 0; i < this->document_path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->document_path(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Column)
}

int Column::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  total_size += 1 * this->document_path_size();
  for (int i = 0; i < this->document_path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->document_path(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Column::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Column*>(&from));
}

void Column::MergeFrom(const Column& from) {
  GOOGLE_CHECK_NE(&from, this);
  document_path_.MergeFrom(from.document_path_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Column::CopyFrom(const Column& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void Column::Swap(Column* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(alias_, other->alias_);
    document_path_.Swap(&other->document_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Column::GetTypeName() const {
  return "Mysqlx.Crud.Column";
}


// ===================================================================

#ifndef _MSC_VER
const int Projection::kSourceFieldNumber;
const int Projection::kAliasFieldNumber;
#endif  // !_MSC_VER

Projection::Projection()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}

void Projection::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  source_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
}

Projection::Projection(const Projection& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = NULL;
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
  }
}

void Projection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Projection& Projection::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Projection* Projection::default_instance_ = NULL;

Projection* Projection::New() const {
  return new Projection;
}

void Projection::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_source()) {
      if (source_ != NULL) source_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        alias_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Projection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Projection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Projection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Projection)
  return false;
#undef DO_
}

void Projection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Projection)
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Projection)
}

int Projection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Expr source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Projection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Projection*>(&from));
}

void Projection::MergeFrom(const Projection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from.source());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Projection::CopyFrom(const Projection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  return true;
}

void Projection::Swap(Projection* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(alias_, other->alias_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Projection::GetTypeName() const {
  return "Mysqlx.Crud.Projection";
}


// ===================================================================

#ifndef _MSC_VER
const int Collection::kNameFieldNumber;
const int Collection::kSchemaFieldNumber;
#endif  // !_MSC_VER

Collection::Collection()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}

void Collection::InitAsDefaultInstance() {
}

Collection::Collection(const Collection& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Collection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Collection& Collection::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Collection* Collection::default_instance_ = NULL;

Collection* Collection::New() const {
  return new Collection;
}

void Collection::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_schema()) {
      if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        schema_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Collection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Collection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_schema;
        break;
      }

      // optional string schema = 2;
      case 2: {
        if (tag == 18) {
         parse_schema:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Collection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Collection)
  return false;
#undef DO_
}

void Collection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Collection)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Collection)
}

int Collection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string schema = 2;
    if (has_schema()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->schema());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Collection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Collection*>(&from));
}

void Collection::MergeFrom(const Collection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_schema()) {
      set_schema(from.schema());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Collection::CopyFrom(const Collection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Collection::Swap(Collection* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(schema_, other->schema_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Collection::GetTypeName() const {
  return "Mysqlx.Crud.Collection";
}


// ===================================================================

#ifndef _MSC_VER
const int Limit::kRowCountFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !_MSC_VER

Limit::Limit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}

void Limit::InitAsDefaultInstance() {
}

Limit::Limit(const Limit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  _cached_size_ = 0;
  row_count_ = GOOGLE_ULONGLONG(0);
  offset_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Limit& Limit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Limit* Limit::default_instance_ = NULL;

Limit* Limit::New() const {
  return new Limit;
}

void Limit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Limit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(row_count_, offset_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Limit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 row_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &row_count_)));
          set_has_row_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // optional uint64 offset = 2;
      case 2: {
        if (tag == 16) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Limit)
  return false;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Limit)
  // required uint64 row_count = 1;
  if (has_row_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->row_count(), output);
  }

  // optional uint64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Limit)
}

int Limit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 row_count = 1;
    if (has_row_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->row_count());
    }

    // optional uint64 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Limit*>(&from));
}

void Limit::MergeFrom(const Limit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_row_count()) {
      set_row_count(from.row_count());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Limit::CopyFrom(const Limit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Limit::Swap(Limit* other) {
  if (other != this) {
    std::swap(row_count_, other->row_count_);
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Limit::GetTypeName() const {
  return "Mysqlx.Crud.Limit";
}


// ===================================================================

bool Order_Direction_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Order_Direction Order::ASC;
const Order_Direction Order::DESC;
const Order_Direction Order::Direction_MIN;
const Order_Direction Order::Direction_MAX;
const int Order::Direction_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Order::kExprFieldNumber;
const int Order::kDirectionFieldNumber;
#endif  // !_MSC_VER

Order::Order()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}

void Order::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  expr_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  expr_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
}

Order::Order(const Order& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  _cached_size_ = 0;
  expr_ = NULL;
  direction_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete expr_;
  }
}

void Order::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Order& Order::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Order* Order::default_instance_ = NULL;

Order* Order::New() const {
  return new Order;
}

void Order::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_expr()) {
      if (expr_ != NULL) expr_->::Mysqlx::Expr::Expr::Clear();
    }
    direction_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Order)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_direction;
        break;
      }

      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2: {
        if (tag == 16) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Order_Direction_IsValid(value)) {
            set_direction(static_cast< ::Mysqlx::Crud::Order_Direction >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Order)
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->expr(), output);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Order)
}

int Order::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Expr expr = 1;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expr());
    }

    // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Order::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Order*>(&from));
}

void Order::MergeFrom(const Order& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_expr()) {
      mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from.expr());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Order::CopyFrom(const Order& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_expr()) {
    if (!this->expr().IsInitialized()) return false;
  }
  return true;
}

void Order::Swap(Order* other) {
  if (other != this) {
    std::swap(expr_, other->expr_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Order::GetTypeName() const {
  return "Mysqlx.Crud.Order";
}


// ===================================================================

bool UpdateOperation_UpdateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UpdateOperation_UpdateType UpdateOperation::SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
const int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UpdateOperation::kSourceFieldNumber;
const int UpdateOperation::kOperationFieldNumber;
const int UpdateOperation::kValueFieldNumber;
#endif  // !_MSC_VER

UpdateOperation::UpdateOperation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
#else
  source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(&::Mysqlx::Expr::ColumnIdentifier::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  value_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
}

UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  _cached_size_ = 0;
  source_ = NULL;
  operation_ = 1;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete value_;
  }
}

void UpdateOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateOperation& UpdateOperation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

UpdateOperation* UpdateOperation::default_instance_ = NULL;

UpdateOperation* UpdateOperation::New() const {
  return new UpdateOperation;
}

void UpdateOperation::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_source()) {
      if (source_ != NULL) source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
    }
    operation_ = 1;
    if (has_value()) {
      if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UpdateOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.UpdateOperation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_operation;
        break;
      }

      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2: {
        if (tag == 16) {
         parse_operation:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value)) {
            set_operation(static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .Mysqlx.Expr.Expr value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.UpdateOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.UpdateOperation)
  return false;
#undef DO_
}

void UpdateOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.UpdateOperation)
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->source(), output);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.UpdateOperation)
}

int UpdateOperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    if (has_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
    }

    // optional .Mysqlx.Expr.Expr value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateOperation*>(&from));
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.source());
    }
    if (from.has_operation()) {
      set_operation(from.operation());
    }
    if (from.has_value()) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::Swap(UpdateOperation* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(operation_, other->operation_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateOperation::GetTypeName() const {
  return "Mysqlx.Crud.UpdateOperation";
}


// ===================================================================

#ifndef _MSC_VER
const int Find::kCollectionFieldNumber;
const int Find::kDataModelFieldNumber;
const int Find::kProjectionFieldNumber;
const int Find::kCriteriaFieldNumber;
const int Find::kArgsFieldNumber;
const int Find::kLimitFieldNumber;
const int Find::kOrderFieldNumber;
const int Find::kGroupingFieldNumber;
const int Find::kGroupingCriteriaFieldNumber;
#endif  // !_MSC_VER

Find::Find()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}

void Find::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
#else
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
#else
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
}

Find::Find(const Find& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  grouping_criteria_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete collection_;
    delete criteria_;
    delete limit_;
    delete grouping_criteria_;
  }
}

void Find::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Find& Find::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Find* Find::default_instance_ = NULL;

Find* Find::New() const {
  return new Find;
}

void Find::Clear() {
  if (_has_bits_[0 / 32] & 43) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  if (has_grouping_criteria()) {
    if (grouping_criteria_ != NULL) grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
  }
  projection_.Clear();
  args_.Clear();
  order_.Clear();
  grouping_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Find::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Find)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_projection;
        break;
      }

      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4: {
        if (tag == 34) {
         parse_projection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_projection;
        if (input->ExpectTag(42)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5: {
        if (tag == 42) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6: {
        if (tag == 50) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 7;
      case 7: {
        if (tag == 58) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_order;
        if (input->ExpectTag(66)) goto parse_grouping;
        break;
      }

      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8: {
        if (tag == 66) {
         parse_grouping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_grouping()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_grouping;
        if (input->ExpectTag(74)) goto parse_grouping_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9: {
        if (tag == 74) {
         parse_grouping_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grouping_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11: {
        if (tag == 90) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Find)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Find)
  return false;
#undef DO_
}

void Find::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Find)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (int i = 0; i < this->projection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->projection(i), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->order(i), output);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (int i = 0; i < this->grouping_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->grouping(i), output);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (has_grouping_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->grouping_criteria(), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->args(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Find)
}

int Find::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 2;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (has_grouping_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->grouping_criteria());
    }

  }
  // repeated .Mysqlx.Crud.Projection projection = 4;
  total_size += 1 * this->projection_size();
  for (int i = 0; i < this->projection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->projection(i));
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  total_size += 1 * this->grouping_size();
  for (int i = 0; i < this->grouping_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->grouping(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Find::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Find*>(&from));
}

void Find::MergeFrom(const Find& from) {
  GOOGLE_CHECK_NE(&from, this);
  projection_.MergeFrom(from.projection_);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_grouping_criteria()) {
      mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.grouping_criteria());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Find::CopyFrom(const Find& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->grouping())) return false;
  if (has_grouping_criteria()) {
    if (!this->grouping_criteria().IsInitialized()) return false;
  }
  return true;
}

void Find::Swap(Find* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    projection_.Swap(&other->projection_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    grouping_.Swap(&other->grouping_);
    std::swap(grouping_criteria_, other->grouping_criteria_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Find::GetTypeName() const {
  return "Mysqlx.Crud.Find";
}


// ===================================================================

#ifndef _MSC_VER
const int Insert_TypedRow::kFieldFieldNumber;
#endif  // !_MSC_VER

Insert_TypedRow::Insert_TypedRow()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::InitAsDefaultInstance() {
}

Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Insert_TypedRow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Insert_TypedRow& Insert_TypedRow::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Insert_TypedRow* Insert_TypedRow::default_instance_ = NULL;

Insert_TypedRow* Insert_TypedRow::New() const {
  return new Insert_TypedRow;
}

void Insert_TypedRow::Clear() {
  field_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Insert_TypedRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert.TypedRow)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1: {
        if (tag == 10) {
         parse_field:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_field;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert.TypedRow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert.TypedRow)
  return false;
#undef DO_
}

void Insert_TypedRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert.TypedRow)
  // repeated .Mysqlx.Expr.Expr field = 1;
  for (int i = 0; i < this->field_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->field(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert.TypedRow)
}

int Insert_TypedRow::ByteSize() const {
  int total_size = 0;

  // repeated .Mysqlx.Expr.Expr field = 1;
  total_size += 1 * this->field_size();
  for (int i = 0; i < this->field_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert_TypedRow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Insert_TypedRow*>(&from));
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
  GOOGLE_CHECK_NE(&from, this);
  field_.MergeFrom(from.field_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->field())) return false;
  return true;
}

void Insert_TypedRow::Swap(Insert_TypedRow* other) {
  if (other != this) {
    field_.Swap(&other->field_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Insert_TypedRow::GetTypeName() const {
  return "Mysqlx.Crud.Insert.TypedRow";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Insert::kCollectionFieldNumber;
const int Insert::kDataModelFieldNumber;
const int Insert::kProjectionFieldNumber;
const int Insert::kRowFieldNumber;
const int Insert::kArgsFieldNumber;
#endif  // !_MSC_VER

Insert::Insert()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}

void Insert::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
#else
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
#endif
}

Insert::Insert(const Insert& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete collection_;
  }
}

void Insert::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Insert& Insert::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Insert* Insert::default_instance_ = NULL;

Insert* Insert::New() const {
  return new Insert;
}

void Insert::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
  }
  projection_.Clear();
  row_.Clear();
  args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Insert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_projection;
        break;
      }

      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3: {
        if (tag == 26) {
         parse_projection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_projection;
        if (input->ExpectTag(34)) goto parse_row;
        break;
      }

      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4: {
        if (tag == 34) {
         parse_row:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_row()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_row;
        if (input->ExpectTag(42)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5: {
        if (tag == 42) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert)
  return false;
#undef DO_
}

void Insert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (int i = 0; i < this->projection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->projection(i), output);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (int i = 0; i < this->row_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->row(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->args(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert)
}

int Insert::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 1;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  // repeated .Mysqlx.Crud.Column projection = 3;
  total_size += 1 * this->projection_size();
  for (int i = 0; i < this->projection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->projection(i));
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  total_size += 1 * this->row_size();
  for (int i = 0; i < this->row_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->row(i));
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Insert*>(&from));
}

void Insert::MergeFrom(const Insert& from) {
  GOOGLE_CHECK_NE(&from, this);
  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Insert::CopyFrom(const Insert& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->row())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  return true;
}

void Insert::Swap(Insert* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    projection_.Swap(&other->projection_);
    row_.Swap(&other->row_);
    args_.Swap(&other->args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Insert::GetTypeName() const {
  return "Mysqlx.Crud.Insert";
}


// ===================================================================

#ifndef _MSC_VER
const int Update::kCollectionFieldNumber;
const int Update::kDataModelFieldNumber;
const int Update::kCriteriaFieldNumber;
const int Update::kArgsFieldNumber;
const int Update::kLimitFieldNumber;
const int Update::kOrderFieldNumber;
const int Update::kOperationFieldNumber;
#endif  // !_MSC_VER

Update::Update()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}

void Update::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
#else
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
#else
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
#endif
}

Update::Update(const Update& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete collection_;
    delete criteria_;
    delete limit_;
  }
}

void Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Update& Update::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Update* Update::default_instance_ = NULL;

Update* Update::New() const {
  return new Update;
}

void Update::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  args_.Clear();
  order_.Clear();
  operation_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Update)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4: {
        if (tag == 34) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5: {
        if (tag == 42) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 6;
      case 6: {
        if (tag == 50) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_order;
        if (input->ExpectTag(58)) goto parse_operation;
        break;
      }

      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7: {
        if (tag == 58) {
         parse_operation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_operation;
        if (input->ExpectTag(66)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8: {
        if (tag == 66) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Update)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->order(i), output);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (int i = 0; i < this->operation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->operation(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->args(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Update)
}

int Update::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 2;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  total_size += 1 * this->operation_size();
  for (int i = 0; i < this->operation_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operation(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Update::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Update*>(&from));
}

void Update::MergeFrom(const Update& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Update::CopyFrom(const Update& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operation())) return false;
  return true;
}

void Update::Swap(Update* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    operation_.Swap(&other->operation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Update::GetTypeName() const {
  return "Mysqlx.Crud.Update";
}


// ===================================================================

#ifndef _MSC_VER
const int Delete::kCollectionFieldNumber;
const int Delete::kDataModelFieldNumber;
const int Delete::kCriteriaFieldNumber;
const int Delete::kArgsFieldNumber;
const int Delete::kLimitFieldNumber;
const int Delete::kOrderFieldNumber;
#endif  // !_MSC_VER

Delete::Delete()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}

void Delete::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
#else
  collection_ = const_cast< ::Mysqlx::Crud::Collection*>(&::Mysqlx::Crud::Collection::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
#else
  limit_ = const_cast< ::Mysqlx::Crud::Limit*>(&::Mysqlx::Crud::Limit::default_instance());
#endif
}

Delete::Delete(const Delete& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
  criteria_ = NULL;
  limit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete collection_;
    delete criteria_;
    delete limit_;
  }
}

void Delete::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Delete& Delete::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fcrud_2eproto();
#endif
  return *default_instance_;
}

Delete* Delete::default_instance_ = NULL;

Delete* Delete::New() const {
  return new Delete;
}

void Delete::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_collection()) {
      if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
    if (has_criteria()) {
      if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
    }
  }
  args_.Clear();
  order_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Delete::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Delete)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data_model;
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16) {
         parse_data_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_criteria;
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3: {
        if (tag == 26) {
         parse_criteria:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_limit;
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4: {
        if (tag == 34) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_order;
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 5;
      case 5: {
        if (tag == 42) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_order;
        if (input->ExpectTag(50)) goto parse_args;
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6: {
        if (tag == 50) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_args;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Delete)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Delete)
  return false;
#undef DO_
}

void Delete::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Delete)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->collection(), output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->criteria(), output);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->limit(), output);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (int i = 0; i < this->order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->order(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->args(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Delete)
}

int Delete::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Crud.Collection collection = 1;
    if (has_collection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collection());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->criteria());
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }

  }
  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  total_size += 1 * this->order_size();
  for (int i = 0; i < this->order_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->order(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Delete::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Delete*>(&from));
}

void Delete::MergeFrom(const Delete& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Delete::CopyFrom(const Delete& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_collection()) {
    if (!this->collection().IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  return true;
}

void Delete::Swap(Delete* other) {
  if (other != this) {
    std::swap(collection_, other->collection_);
    std::swap(data_model_, other->data_model_);
    std::swap(criteria_, other->criteria_);
    args_.Swap(&other->args_);
    std::swap(limit_, other->limit_);
    order_.Swap(&other->order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Delete::GetTypeName() const {
  return "Mysqlx.Crud.Delete";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

// @@protoc_insertion_point(global_scope)
