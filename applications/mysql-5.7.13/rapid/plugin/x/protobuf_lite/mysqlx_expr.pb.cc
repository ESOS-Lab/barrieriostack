// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_expr.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mysqlx_expr.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Expr {

void protobuf_ShutdownFile_mysqlx_5fexpr_2eproto() {
  delete Expr::default_instance_;
  delete Identifier::default_instance_;
  delete DocumentPathItem::default_instance_;
  delete ColumnIdentifier::default_instance_;
  delete FunctionCall::default_instance_;
  delete Operator::default_instance_;
  delete Object::default_instance_;
  delete Object_ObjectField::default_instance_;
  delete Array::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_mysqlx_5fexpr_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_mysqlx_5fexpr_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::Mysqlx::Datatypes::protobuf_AddDesc_mysqlx_5fdatatypes_2eproto();
  Expr::default_instance_ = new Expr();
  Identifier::default_instance_ = new Identifier();
  DocumentPathItem::default_instance_ = new DocumentPathItem();
  ColumnIdentifier::default_instance_ = new ColumnIdentifier();
  FunctionCall::default_instance_ = new FunctionCall();
  Operator::default_instance_ = new Operator();
  Object::default_instance_ = new Object();
  Object_ObjectField::default_instance_ = new Object_ObjectField();
  Array::default_instance_ = new Array();
  Expr::default_instance_->InitAsDefaultInstance();
  Identifier::default_instance_->InitAsDefaultInstance();
  DocumentPathItem::default_instance_->InitAsDefaultInstance();
  ColumnIdentifier::default_instance_->InitAsDefaultInstance();
  FunctionCall::default_instance_->InitAsDefaultInstance();
  Operator::default_instance_->InitAsDefaultInstance();
  Object::default_instance_->InitAsDefaultInstance();
  Object_ObjectField::default_instance_->InitAsDefaultInstance();
  Array::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mysqlx_5fexpr_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_mysqlx_5fexpr_2eproto_once_);
void protobuf_AddDesc_mysqlx_5fexpr_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_mysqlx_5fexpr_2eproto_once_,
                 &protobuf_AddDesc_mysqlx_5fexpr_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mysqlx_5fexpr_2eproto {
  StaticDescriptorInitializer_mysqlx_5fexpr_2eproto() {
    protobuf_AddDesc_mysqlx_5fexpr_2eproto();
  }
} static_descriptor_initializer_mysqlx_5fexpr_2eproto_;
#endif

// ===================================================================

bool Expr_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Expr_Type Expr::IDENT;
const Expr_Type Expr::LITERAL;
const Expr_Type Expr::VARIABLE;
const Expr_Type Expr::FUNC_CALL;
const Expr_Type Expr::OPERATOR;
const Expr_Type Expr::PLACEHOLDER;
const Expr_Type Expr::OBJECT;
const Expr_Type Expr::ARRAY;
const Expr_Type Expr::Type_MIN;
const Expr_Type Expr::Type_MAX;
const int Expr::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Expr::kTypeFieldNumber;
const int Expr::kIdentifierFieldNumber;
const int Expr::kVariableFieldNumber;
const int Expr::kLiteralFieldNumber;
const int Expr::kFunctionCallFieldNumber;
const int Expr::kOperatorFieldNumber;
const int Expr::kPositionFieldNumber;
const int Expr::kObjectFieldNumber;
const int Expr::kArrayFieldNumber;
#endif  // !_MSC_VER

Expr::Expr()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Expr)
}

void Expr::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  identifier_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
#else
  identifier_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(&::Mysqlx::Expr::ColumnIdentifier::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  literal_ = const_cast< ::Mysqlx::Datatypes::Scalar*>(
      ::Mysqlx::Datatypes::Scalar::internal_default_instance());
#else
  literal_ = const_cast< ::Mysqlx::Datatypes::Scalar*>(&::Mysqlx::Datatypes::Scalar::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  function_call_ = const_cast< ::Mysqlx::Expr::FunctionCall*>(
      ::Mysqlx::Expr::FunctionCall::internal_default_instance());
#else
  function_call_ = const_cast< ::Mysqlx::Expr::FunctionCall*>(&::Mysqlx::Expr::FunctionCall::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  operator__ = const_cast< ::Mysqlx::Expr::Operator*>(
      ::Mysqlx::Expr::Operator::internal_default_instance());
#else
  operator__ = const_cast< ::Mysqlx::Expr::Operator*>(&::Mysqlx::Expr::Operator::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_ = const_cast< ::Mysqlx::Expr::Object*>(
      ::Mysqlx::Expr::Object::internal_default_instance());
#else
  object_ = const_cast< ::Mysqlx::Expr::Object*>(&::Mysqlx::Expr::Object::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  array_ = const_cast< ::Mysqlx::Expr::Array*>(
      ::Mysqlx::Expr::Array::internal_default_instance());
#else
  array_ = const_cast< ::Mysqlx::Expr::Array*>(&::Mysqlx::Expr::Array::default_instance());
#endif
}

Expr::Expr(const Expr& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Expr)
}

void Expr::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  identifier_ = NULL;
  variable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  literal_ = NULL;
  function_call_ = NULL;
  operator__ = NULL;
  position_ = 0u;
  object_ = NULL;
  array_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Expr::~Expr() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Expr)
  SharedDtor();
}

void Expr::SharedDtor() {
  if (variable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete variable_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete identifier_;
    delete literal_;
    delete function_call_;
    delete operator__;
    delete object_;
    delete array_;
  }
}

void Expr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Expr& Expr::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Expr* Expr::default_instance_ = NULL;

Expr* Expr::New() const {
  return new Expr;
}

void Expr::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    type_ = 1;
    if (has_identifier()) {
      if (identifier_ != NULL) identifier_->::Mysqlx::Expr::ColumnIdentifier::Clear();
    }
    if (has_variable()) {
      if (variable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        variable_->clear();
      }
    }
    if (has_literal()) {
      if (literal_ != NULL) literal_->::Mysqlx::Datatypes::Scalar::Clear();
    }
    if (has_function_call()) {
      if (function_call_ != NULL) function_call_->::Mysqlx::Expr::FunctionCall::Clear();
    }
    if (has_operator_()) {
      if (operator__ != NULL) operator__->::Mysqlx::Expr::Operator::Clear();
    }
    position_ = 0u;
    if (has_object()) {
      if (object_ != NULL) object_->::Mysqlx::Expr::Object::Clear();
    }
  }
  if (has_array()) {
    if (array_ != NULL) array_->::Mysqlx::Expr::Array::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Expr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Expr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Expr::Expr_Type_IsValid(value)) {
            set_type(static_cast< ::Mysqlx::Expr::Expr_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_identifier;
        break;
      }

      // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
      case 2: {
        if (tag == 18) {
         parse_identifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_variable;
        break;
      }

      // optional string variable = 3;
      case 3: {
        if (tag == 26) {
         parse_variable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_variable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_literal;
        break;
      }

      // optional .Mysqlx.Datatypes.Scalar literal = 4;
      case 4: {
        if (tag == 34) {
         parse_literal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_literal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_function_call;
        break;
      }

      // optional .Mysqlx.Expr.FunctionCall function_call = 5;
      case 5: {
        if (tag == 42) {
         parse_function_call:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_function_call()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_operator;
        break;
      }

      // optional .Mysqlx.Expr.Operator operator = 6;
      case 6: {
        if (tag == 50) {
         parse_operator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operator_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_position;
        break;
      }

      // optional uint32 position = 7;
      case 7: {
        if (tag == 56) {
         parse_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_object;
        break;
      }

      // optional .Mysqlx.Expr.Object object = 8;
      case 8: {
        if (tag == 66) {
         parse_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_array;
        break;
      }

      // optional .Mysqlx.Expr.Array array = 9;
      case 9: {
        if (tag == 74) {
         parse_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_array()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Expr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Expr)
  return false;
#undef DO_
}

void Expr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Expr)
  // required .Mysqlx.Expr.Expr.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->identifier(), output);
  }

  // optional string variable = 3;
  if (has_variable()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->variable(), output);
  }

  // optional .Mysqlx.Datatypes.Scalar literal = 4;
  if (has_literal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->literal(), output);
  }

  // optional .Mysqlx.Expr.FunctionCall function_call = 5;
  if (has_function_call()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->function_call(), output);
  }

  // optional .Mysqlx.Expr.Operator operator = 6;
  if (has_operator_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->operator_(), output);
  }

  // optional uint32 position = 7;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->position(), output);
  }

  // optional .Mysqlx.Expr.Object object = 8;
  if (has_object()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->object(), output);
  }

  // optional .Mysqlx.Expr.Array array = 9;
  if (has_array()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->array(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Expr)
}

int Expr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Expr.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->identifier());
    }

    // optional string variable = 3;
    if (has_variable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->variable());
    }

    // optional .Mysqlx.Datatypes.Scalar literal = 4;
    if (has_literal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->literal());
    }

    // optional .Mysqlx.Expr.FunctionCall function_call = 5;
    if (has_function_call()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->function_call());
    }

    // optional .Mysqlx.Expr.Operator operator = 6;
    if (has_operator_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operator_());
    }

    // optional uint32 position = 7;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->position());
    }

    // optional .Mysqlx.Expr.Object object = 8;
    if (has_object()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Mysqlx.Expr.Array array = 9;
    if (has_array()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->array());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Expr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Expr*>(&from));
}

void Expr::MergeFrom(const Expr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_identifier()) {
      mutable_identifier()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.identifier());
    }
    if (from.has_variable()) {
      set_variable(from.variable());
    }
    if (from.has_literal()) {
      mutable_literal()->::Mysqlx::Datatypes::Scalar::MergeFrom(from.literal());
    }
    if (from.has_function_call()) {
      mutable_function_call()->::Mysqlx::Expr::FunctionCall::MergeFrom(from.function_call());
    }
    if (from.has_operator_()) {
      mutable_operator_()->::Mysqlx::Expr::Operator::MergeFrom(from.operator_());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
    if (from.has_object()) {
      mutable_object()->::Mysqlx::Expr::Object::MergeFrom(from.object());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_array()) {
      mutable_array()->::Mysqlx::Expr::Array::MergeFrom(from.array());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Expr::CopyFrom(const Expr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Expr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_identifier()) {
    if (!this->identifier().IsInitialized()) return false;
  }
  if (has_literal()) {
    if (!this->literal().IsInitialized()) return false;
  }
  if (has_function_call()) {
    if (!this->function_call().IsInitialized()) return false;
  }
  if (has_operator_()) {
    if (!this->operator_().IsInitialized()) return false;
  }
  if (has_object()) {
    if (!this->object().IsInitialized()) return false;
  }
  if (has_array()) {
    if (!this->array().IsInitialized()) return false;
  }
  return true;
}

void Expr::Swap(Expr* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(identifier_, other->identifier_);
    std::swap(variable_, other->variable_);
    std::swap(literal_, other->literal_);
    std::swap(function_call_, other->function_call_);
    std::swap(operator__, other->operator__);
    std::swap(position_, other->position_);
    std::swap(object_, other->object_);
    std::swap(array_, other->array_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Expr::GetTypeName() const {
  return "Mysqlx.Expr.Expr";
}


// ===================================================================

#ifndef _MSC_VER
const int Identifier::kNameFieldNumber;
const int Identifier::kSchemaNameFieldNumber;
#endif  // !_MSC_VER

Identifier::Identifier()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Identifier)
}

void Identifier::InitAsDefaultInstance() {
}

Identifier::Identifier(const Identifier& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Identifier)
}

void Identifier::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Identifier::~Identifier() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Identifier)
  SharedDtor();
}

void Identifier::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Identifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Identifier& Identifier::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Identifier* Identifier::default_instance_ = NULL;

Identifier* Identifier::New() const {
  return new Identifier;
}

void Identifier::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_schema_name()) {
      if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        schema_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Identifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Identifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_schema_name;
        break;
      }

      // optional string schema_name = 2;
      case 2: {
        if (tag == 18) {
         parse_schema_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Identifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Identifier)
  return false;
#undef DO_
}

void Identifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Identifier)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema_name = 2;
  if (has_schema_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Identifier)
}

int Identifier::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string schema_name = 2;
    if (has_schema_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->schema_name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Identifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Identifier*>(&from));
}

void Identifier::MergeFrom(const Identifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_schema_name()) {
      set_schema_name(from.schema_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Identifier::CopyFrom(const Identifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Identifier::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Identifier::Swap(Identifier* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(schema_name_, other->schema_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Identifier::GetTypeName() const {
  return "Mysqlx.Expr.Identifier";
}


// ===================================================================

bool DocumentPathItem_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DocumentPathItem_Type DocumentPathItem::MEMBER;
const DocumentPathItem_Type DocumentPathItem::MEMBER_ASTERISK;
const DocumentPathItem_Type DocumentPathItem::ARRAY_INDEX;
const DocumentPathItem_Type DocumentPathItem::ARRAY_INDEX_ASTERISK;
const DocumentPathItem_Type DocumentPathItem::DOUBLE_ASTERISK;
const DocumentPathItem_Type DocumentPathItem::Type_MIN;
const DocumentPathItem_Type DocumentPathItem::Type_MAX;
const int DocumentPathItem::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DocumentPathItem::kTypeFieldNumber;
const int DocumentPathItem::kValueFieldNumber;
const int DocumentPathItem::kIndexFieldNumber;
#endif  // !_MSC_VER

DocumentPathItem::DocumentPathItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.DocumentPathItem)
}

void DocumentPathItem::InitAsDefaultInstance() {
}

DocumentPathItem::DocumentPathItem(const DocumentPathItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.DocumentPathItem)
}

void DocumentPathItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DocumentPathItem::~DocumentPathItem() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.DocumentPathItem)
  SharedDtor();
}

void DocumentPathItem::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DocumentPathItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DocumentPathItem& DocumentPathItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

DocumentPathItem* DocumentPathItem::default_instance_ = NULL;

DocumentPathItem* DocumentPathItem::New() const {
  return new DocumentPathItem;
}

void DocumentPathItem::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 1;
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
    index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DocumentPathItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.DocumentPathItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Expr::DocumentPathItem_Type_IsValid(value)) {
            set_type(static_cast< ::Mysqlx::Expr::DocumentPathItem_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // optional uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.DocumentPathItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.DocumentPathItem)
  return false;
#undef DO_
}

void DocumentPathItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.DocumentPathItem)
  // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  // optional uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.DocumentPathItem)
}

int DocumentPathItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional uint32 index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DocumentPathItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DocumentPathItem*>(&from));
}

void DocumentPathItem::MergeFrom(const DocumentPathItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DocumentPathItem::CopyFrom(const DocumentPathItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentPathItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DocumentPathItem::Swap(DocumentPathItem* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(value_, other->value_);
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DocumentPathItem::GetTypeName() const {
  return "Mysqlx.Expr.DocumentPathItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnIdentifier::kDocumentPathFieldNumber;
const int ColumnIdentifier::kNameFieldNumber;
const int ColumnIdentifier::kTableNameFieldNumber;
const int ColumnIdentifier::kSchemaNameFieldNumber;
#endif  // !_MSC_VER

ColumnIdentifier::ColumnIdentifier()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.ColumnIdentifier)
}

void ColumnIdentifier::InitAsDefaultInstance() {
}

ColumnIdentifier::ColumnIdentifier(const ColumnIdentifier& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.ColumnIdentifier)
}

void ColumnIdentifier::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnIdentifier::~ColumnIdentifier() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.ColumnIdentifier)
  SharedDtor();
}

void ColumnIdentifier::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_name_;
  }
  if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ColumnIdentifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ColumnIdentifier& ColumnIdentifier::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

ColumnIdentifier* ColumnIdentifier::default_instance_ = NULL;

ColumnIdentifier* ColumnIdentifier::New() const {
  return new ColumnIdentifier;
}

void ColumnIdentifier::Clear() {
  if (_has_bits_[0 / 32] & 14) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_table_name()) {
      if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        table_name_->clear();
      }
    }
    if (has_schema_name()) {
      if (schema_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        schema_name_->clear();
      }
    }
  }
  document_path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ColumnIdentifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.ColumnIdentifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
      case 1: {
        if (tag == 10) {
         parse_document_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_document_path;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_table_name;
        break;
      }

      // optional string table_name = 3;
      case 3: {
        if (tag == 26) {
         parse_table_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_table_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_schema_name;
        break;
      }

      // optional string schema_name = 4;
      case 4: {
        if (tag == 34) {
         parse_schema_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.ColumnIdentifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.ColumnIdentifier)
  return false;
#undef DO_
}

void ColumnIdentifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.ColumnIdentifier)
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  for (int i = 0; i < this->document_path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->document_path(i), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string table_name = 3;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->table_name(), output);
  }

  // optional string schema_name = 4;
  if (has_schema_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->schema_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.ColumnIdentifier)
}

int ColumnIdentifier::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string table_name = 3;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->table_name());
    }

    // optional string schema_name = 4;
    if (has_schema_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->schema_name());
    }

  }
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  total_size += 1 * this->document_path_size();
  for (int i = 0; i < this->document_path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->document_path(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnIdentifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ColumnIdentifier*>(&from));
}

void ColumnIdentifier::MergeFrom(const ColumnIdentifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  document_path_.MergeFrom(from.document_path_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_table_name()) {
      set_table_name(from.table_name());
    }
    if (from.has_schema_name()) {
      set_schema_name(from.schema_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ColumnIdentifier::CopyFrom(const ColumnIdentifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnIdentifier::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void ColumnIdentifier::Swap(ColumnIdentifier* other) {
  if (other != this) {
    document_path_.Swap(&other->document_path_);
    std::swap(name_, other->name_);
    std::swap(table_name_, other->table_name_);
    std::swap(schema_name_, other->schema_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ColumnIdentifier::GetTypeName() const {
  return "Mysqlx.Expr.ColumnIdentifier";
}


// ===================================================================

#ifndef _MSC_VER
const int FunctionCall::kNameFieldNumber;
const int FunctionCall::kParamFieldNumber;
#endif  // !_MSC_VER

FunctionCall::FunctionCall()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.FunctionCall)
}

void FunctionCall::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  name_ = const_cast< ::Mysqlx::Expr::Identifier*>(
      ::Mysqlx::Expr::Identifier::internal_default_instance());
#else
  name_ = const_cast< ::Mysqlx::Expr::Identifier*>(&::Mysqlx::Expr::Identifier::default_instance());
#endif
}

FunctionCall::FunctionCall(const FunctionCall& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.FunctionCall)
}

void FunctionCall::SharedCtor() {
  _cached_size_ = 0;
  name_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FunctionCall::~FunctionCall() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.FunctionCall)
  SharedDtor();
}

void FunctionCall::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete name_;
  }
}

void FunctionCall::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FunctionCall& FunctionCall::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

FunctionCall* FunctionCall::default_instance_ = NULL;

FunctionCall* FunctionCall::New() const {
  return new FunctionCall;
}

void FunctionCall::Clear() {
  if (has_name()) {
    if (name_ != NULL) name_->::Mysqlx::Expr::Identifier::Clear();
  }
  param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool FunctionCall::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.FunctionCall)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Identifier name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        break;
      }

      // repeated .Mysqlx.Expr.Expr param = 2;
      case 2: {
        if (tag == 18) {
         parse_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.FunctionCall)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.FunctionCall)
  return false;
#undef DO_
}

void FunctionCall::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.FunctionCall)
  // required .Mysqlx.Expr.Identifier name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->name(), output);
  }

  // repeated .Mysqlx.Expr.Expr param = 2;
  for (int i = 0; i < this->param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->param(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.FunctionCall)
}

int FunctionCall::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Mysqlx.Expr.Identifier name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name());
    }

  }
  // repeated .Mysqlx.Expr.Expr param = 2;
  total_size += 1 * this->param_size();
  for (int i = 0; i < this->param_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->param(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FunctionCall::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FunctionCall*>(&from));
}

void FunctionCall::MergeFrom(const FunctionCall& from) {
  GOOGLE_CHECK_NE(&from, this);
  param_.MergeFrom(from.param_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      mutable_name()->::Mysqlx::Expr::Identifier::MergeFrom(from.name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void FunctionCall::CopyFrom(const FunctionCall& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionCall::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_name()) {
    if (!this->name().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->param())) return false;
  return true;
}

void FunctionCall::Swap(FunctionCall* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    param_.Swap(&other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FunctionCall::GetTypeName() const {
  return "Mysqlx.Expr.FunctionCall";
}


// ===================================================================

#ifndef _MSC_VER
const int Operator::kNameFieldNumber;
const int Operator::kParamFieldNumber;
#endif  // !_MSC_VER

Operator::Operator()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Operator)
}

void Operator::InitAsDefaultInstance() {
}

Operator::Operator(const Operator& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Operator)
}

void Operator::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Operator::~Operator() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Operator)
  SharedDtor();
}

void Operator::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Operator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Operator& Operator::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Operator* Operator::default_instance_ = NULL;

Operator* Operator::New() const {
  return new Operator;
}

void Operator::Clear() {
  if (has_name()) {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      name_->clear();
    }
  }
  param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Operator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Operator)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        break;
      }

      // repeated .Mysqlx.Expr.Expr param = 2;
      case 2: {
        if (tag == 18) {
         parse_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_param;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Operator)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Operator)
  return false;
#undef DO_
}

void Operator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Operator)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .Mysqlx.Expr.Expr param = 2;
  for (int i = 0; i < this->param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->param(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Operator)
}

int Operator::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .Mysqlx.Expr.Expr param = 2;
  total_size += 1 * this->param_size();
  for (int i = 0; i < this->param_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->param(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Operator::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Operator*>(&from));
}

void Operator::MergeFrom(const Operator& from) {
  GOOGLE_CHECK_NE(&from, this);
  param_.MergeFrom(from.param_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Operator::CopyFrom(const Operator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operator::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->param())) return false;
  return true;
}

void Operator::Swap(Operator* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    param_.Swap(&other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Operator::GetTypeName() const {
  return "Mysqlx.Expr.Operator";
}


// ===================================================================

#ifndef _MSC_VER
const int Object_ObjectField::kKeyFieldNumber;
const int Object_ObjectField::kValueFieldNumber;
#endif  // !_MSC_VER

Object_ObjectField::Object_ObjectField()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Object.ObjectField)
}

void Object_ObjectField::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
#else
  value_ = const_cast< ::Mysqlx::Expr::Expr*>(&::Mysqlx::Expr::Expr::default_instance());
#endif
}

Object_ObjectField::Object_ObjectField(const Object_ObjectField& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Object.ObjectField)
}

void Object_ObjectField::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Object_ObjectField::~Object_ObjectField() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Object.ObjectField)
  SharedDtor();
}

void Object_ObjectField::SharedDtor() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete value_;
  }
}

void Object_ObjectField::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Object_ObjectField& Object_ObjectField::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Object_ObjectField* Object_ObjectField::default_instance_ = NULL;

Object_ObjectField* Object_ObjectField::New() const {
  return new Object_ObjectField;
}

void Object_ObjectField::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Object_ObjectField::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Object.ObjectField)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required .Mysqlx.Expr.Expr value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Object.ObjectField)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Object.ObjectField)
  return false;
#undef DO_
}

void Object_ObjectField::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Object.ObjectField)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // required .Mysqlx.Expr.Expr value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Object.ObjectField)
}

int Object_ObjectField::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // required .Mysqlx.Expr.Expr value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Object_ObjectField::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Object_ObjectField*>(&from));
}

void Object_ObjectField::MergeFrom(const Object_ObjectField& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Object_ObjectField::CopyFrom(const Object_ObjectField& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object_ObjectField::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void Object_ObjectField::Swap(Object_ObjectField* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Object_ObjectField::GetTypeName() const {
  return "Mysqlx.Expr.Object.ObjectField";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Object::kFldFieldNumber;
#endif  // !_MSC_VER

Object::Object()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Object)
}

void Object::InitAsDefaultInstance() {
}

Object::Object(const Object& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Object)
}

void Object::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Object::~Object() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Object)
  SharedDtor();
}

void Object::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Object::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Object& Object::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Object* Object::default_instance_ = NULL;

Object* Object::New() const {
  return new Object;
}

void Object::Clear() {
  fld_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Object::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Object)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
      case 1: {
        if (tag == 10) {
         parse_fld:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fld()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_fld;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Object)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Object)
  return false;
#undef DO_
}

void Object::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Object)
  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  for (int i = 0; i < this->fld_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->fld(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Object)
}

int Object::ByteSize() const {
  int total_size = 0;

  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  total_size += 1 * this->fld_size();
  for (int i = 0; i < this->fld_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fld(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Object::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Object*>(&from));
}

void Object::MergeFrom(const Object& from) {
  GOOGLE_CHECK_NE(&from, this);
  fld_.MergeFrom(from.fld_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Object::CopyFrom(const Object& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->fld())) return false;
  return true;
}

void Object::Swap(Object* other) {
  if (other != this) {
    fld_.Swap(&other->fld_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Object::GetTypeName() const {
  return "Mysqlx.Expr.Object";
}


// ===================================================================

#ifndef _MSC_VER
const int Array::kValueFieldNumber;
#endif  // !_MSC_VER

Array::Array()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Expr.Array)
}

void Array::InitAsDefaultInstance() {
}

Array::Array(const Array& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Expr.Array)
}

void Array::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Array::~Array() {
  // @@protoc_insertion_point(destructor:Mysqlx.Expr.Array)
  SharedDtor();
}

void Array::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Array::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Array& Array::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mysqlx_5fexpr_2eproto();
#endif
  return *default_instance_;
}

Array* Array::default_instance_ = NULL;

Array* Array::New() const {
  return new Array;
}

void Array::Clear() {
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Array::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:Mysqlx.Expr.Array)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr value = 1;
      case 1: {
        if (tag == 10) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Expr.Array)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Expr.Array)
  return false;
#undef DO_
}

void Array::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Expr.Array)
  // repeated .Mysqlx.Expr.Expr value = 1;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->value(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:Mysqlx.Expr.Array)
}

int Array::ByteSize() const {
  int total_size = 0;

  // repeated .Mysqlx.Expr.Expr value = 1;
  total_size += 1 * this->value_size();
  for (int i = 0; i < this->value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->value(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Array::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Array*>(&from));
}

void Array::MergeFrom(const Array& from) {
  GOOGLE_CHECK_NE(&from, this);
  value_.MergeFrom(from.value_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Array::CopyFrom(const Array& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Array::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->value())) return false;
  return true;
}

void Array::Swap(Array* other) {
  if (other != this) {
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Array::GetTypeName() const {
  return "Mysqlx.Expr.Array";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Expr
}  // namespace Mysqlx

// @@protoc_insertion_point(global_scope)
